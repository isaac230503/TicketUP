-- ######################################################################
-- # ETAPA 1: LIMPEZA DA ESTRUTURA (DDL DROP)
-- ######################################################################

-- A ordem do DROP é CRÍTICA devido às chaves estrangeiras.
DROP TABLE IF EXISTS Ingresso_Detalhe CASCADE;
DROP TABLE IF EXISTS Item_Pedido CASCADE;
DROP TABLE IF EXISTS Estoque_Ingresso CASCADE;
DROP TABLE IF EXISTS Pagamento CASCADE;
DROP TABLE IF EXISTS Pedido CASCADE;
DROP TABLE IF EXISTS Tipo_Ingresso CASCADE;
DROP TABLE IF EXISTS Setor CASCADE;
DROP TABLE IF EXISTS Evento CASCADE;
DROP TABLE IF EXISTS Organizador CASCADE;
DROP TABLE IF EXISTS Usuario CASCADE;
-- Novas tabelas de Referência
DROP TABLE IF EXISTS Status_Transacao_Ref CASCADE;
DROP TABLE IF EXISTS Metodo_Pagamento_Ref CASCADE;
DROP TABLE IF EXISTS Status_Pedido_Ref CASCADE;
DROP TABLE IF EXISTS Tipo_Usuario_Ref CASCADE;


-- ######################################################################
-- # ETAPA 2: TABELAS DE REFERÊNCIA (LOOKUP TABLES - NORMALIZAÇÃO)
-- ######################################################################

-- Referência para Tipo de Usuário (CLIENTE, ORGANIZADOR)
CREATE TABLE TIPO_USUARIO_REF (
    ID_TIPO_USUARIO SERIAL PRIMARY KEY,
    NOME VARCHAR(20) UNIQUE NOT NULL
);

-- Referência para Status de Pedido (PENDENTE, APROVADO, etc.)
CREATE TABLE STATUS_PEDIDO_REF (
    ID_STATUS_PEDIDO SERIAL PRIMARY KEY,
    NOME VARCHAR(50) UNIQUE NOT NULL
);

-- Referência para Método de Pagamento (PIX, CREDITO, etc.)
CREATE TABLE METODO_PAGAMENTO_REF (
    ID_METODO_PAGAMENTO SERIAL PRIMARY KEY,
    NOME VARCHAR(50) UNIQUE NOT NULL
);

-- Referência para Status de Transação (AUTORIZADO, RECUSADO, etc.)
CREATE TABLE STATUS_TRANSACAO_REF (
    ID_STATUS_TRANSACAO SERIAL PRIMARY KEY,
    NOME VARCHAR(50) UNIQUE NOT NULL
);


-- ######################################################################
-- # ETAPA 3: CRIAÇÃO DA ESTRUTURA PRINCIPAL (DDL CREATE)
-- ######################################################################


-- 1. Tabela USUARIO (Agora usa FK para Tipo)
CREATE TABLE USUARIO (
    ID_USUARIO SERIAL PRIMARY KEY,
    NOME VARCHAR(255) NOT NULL,
    EMAIL VARCHAR(255) UNIQUE NOT NULL,
    SENHA VARCHAR(255) NOT NULL,
    TELEFONE VARCHAR(15),
    DATA_CADASTRO TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    DATA_ATUALIZACAO TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    -- CHAVE ESTRANGEIRA para Tipo de Usuário
    ID_TIPO_USUARIO INTEGER NOT NULL,
    FOREIGN KEY (ID_TIPO_USUARIO) REFERENCES TIPO_USUARIO_REF (ID_TIPO_USUARIO)
);

-- 2. Tabela ORGANIZADOR
CREATE TABLE ORGANIZADOR (
    ID_ORGANIZADOR SERIAL PRIMARY KEY,
    NOME_FANTASIA VARCHAR(255) NOT NULL,
    CNPJ CHAR(14) UNIQUE,
    CPF CHAR(11) UNIQUE,
    TELEFONE_COMERCIAL VARCHAR(15),
    ID_USUARIO INTEGER UNIQUE NOT NULL,
    FOREIGN KEY (ID_USUARIO) REFERENCES USUARIO (ID_USUARIO)
);

-- 3. Tabela EVENTO
CREATE TABLE EVENTO (
    ID_EVENTO SERIAL PRIMARY KEY,
    DATA_HORARIO_INICIO TIMESTAMP NOT NULL,
    DATA_HORARIO_FIM TIMESTAMP,
    ENDERECO VARCHAR(255) NOT NULL,
    AVALIACAO NUMERIC(2, 1),
    NOME VARCHAR(255) NOT NULL,
    DESCRICAO VARCHAR(1000),
    ID_ORGANIZADOR INTEGER NOT NULL,
    DATA_ATUALIZACAO TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    FOREIGN KEY (ID_ORGANIZADOR) REFERENCES ORGANIZADOR (ID_ORGANIZADOR),
    CHECK (AVALIACAO IS NULL OR (AVALIACAO >= 0.0 AND AVALIACAO <= 5.0))
);

-- 4. Tabela SETOR
CREATE TABLE SETOR (
    ID_SETOR SERIAL PRIMARY KEY,
    NOME_SETOR VARCHAR(100) NOT NULL,
    CAPACIDADE INTEGER NOT NULL,
    DESCRICAO VARCHAR(255),
    ID_EVENTO INTEGER NOT NULL,
    FOREIGN KEY (ID_EVENTO) REFERENCES EVENTO (ID_EVENTO),
    CHECK (CAPACIDADE > 0)
);

-- 5. Tabela TIPO_INGRESSO (Colunas Geradas mantidas para consistência do cálculo)
CREATE TABLE TIPO_INGRESSO (
    ID_TIPO_INGRESSO SERIAL PRIMARY KEY,
    NOME VARCHAR(100) NOT NULL,
    PRECO_BASE DECIMAL(10, 2) NOT NULL,
    TAXA_SERVICO DECIMAL(10, 2) DEFAULT 0.00,
    PRECO_FINAL DECIMAL(10, 2) GENERATED ALWAYS AS (PRECO_BASE + TAXA_SERVICO) STORED,
    ID_SETOR INTEGER NOT NULL,
    FOREIGN KEY (ID_SETOR) REFERENCES SETOR (ID_SETOR),
    CHECK (PRECO_BASE >= 0.00),
    CHECK (TAXA_SERVICO >= 0.00)
);

-- 6. Tabela ESTOQUE_INGRESSO
CREATE TABLE ESTOQUE_INGRESSO (
    ID_ESTOQUE SERIAL PRIMARY KEY,
    ID_TIPO_INGRESSO INTEGER UNIQUE NOT NULL,
    QUANTIDADE_TOTAL NUMERIC NOT NULL,
    QUANTIDADE_VENDIDA NUMERIC DEFAULT 0,
    DATA_LIMITE_VENDA DATE,
    FOREIGN KEY (ID_TIPO_INGRESSO) REFERENCES TIPO_INGRESSO (ID_TIPO_INGRESSO),
    CHECK (QUANTIDADE_TOTAL >= 0),
    CHECK (QUANTIDADE_VENDIDA >= 0),
    CHECK (QUANTIDADE_VENDIDA <= QUANTIDADE_TOTAL)
);

-- 7. Tabela PEDIDO (Agora usa FK para Status)
CREATE TABLE PEDIDO (
    ID_PEDIDO SERIAL PRIMARY KEY,
    ID_USUARIO INTEGER NOT NULL,
    DATA_PEDIDO TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    VALOR_TOTAL NUMERIC(10, 2) NOT NULL,
    -- CHAVE ESTRANGEIRA para Status do Pedido
    ID_STATUS_PEDIDO INTEGER NOT NULL,
    FOREIGN KEY (ID_USUARIO) REFERENCES USUARIO (ID_USUARIO),
    FOREIGN KEY (ID_STATUS_PEDIDO) REFERENCES STATUS_PEDIDO_REF (ID_STATUS_PEDIDO),
    CHECK (VALOR_TOTAL >= 0.00)
);

-- 8. Tabela PAGAMENTO (Agora usa FKs para Método e Status)
CREATE TABLE PAGAMENTO (
    ID_PAGAMENTO SERIAL PRIMARY KEY,
    ID_PEDIDO INTEGER UNIQUE NOT NULL,
    VALOR_PAGO NUMERIC(10, 2) NOT NULL,
    DATA_PAGAMENTO TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- CHAVES ESTRANGEIRAS para Tipo e Status da Transação
    ID_METODO_PAGAMENTO INTEGER NOT NULL,
    ID_STATUS_TRANSACAO INTEGER NOT NULL,
    
    FOREIGN KEY (ID_PEDIDO) REFERENCES PEDIDO (ID_PEDIDO),
    FOREIGN KEY (ID_METODO_PAGAMENTO) REFERENCES METODO_PAGAMENTO_REF (ID_METODO_PAGAMENTO),
    FOREIGN KEY (ID_STATUS_TRANSACAO) REFERENCES STATUS_TRANSACAO_REF (ID_STATUS_TRANSACAO)
);

-- 9. Tabela ITEM_PEDIDO
CREATE TABLE ITEM_PEDIDO (
    ID_ITEM_PEDIDO SERIAL PRIMARY KEY,
    ID_PEDIDO INTEGER NOT NULL,
    ID_TIPO_INGRESSO INTEGER NOT NULL,
    QUANTIDADE_COMPRADA INTEGER NOT NULL,
    PRECO_UNITARIO_FINAL DECIMAL(10, 2) NOT NULL,
    FOREIGN KEY (ID_PEDIDO) REFERENCES PEDIDO (ID_PEDIDO),
    FOREIGN KEY (ID_TIPO_INGRESSO) REFERENCES TIPO_INGRESSO (ID_TIPO_INGRESSO),
    CHECK (QUANTIDADE_COMPRADA > 0),
    CHECK (PRECO_UNITARIO_FINAL >= 0.00)
);

-- 10. Tabela INGRESSO_DETALHE
CREATE TABLE INGRESSO_DETALHE (
    ID_INGRESSO_DETALHE SERIAL PRIMARY KEY,
    ID_ITEM_PEDIDO INTEGER NOT NULL,
    QR_CODE VARCHAR(255) UNIQUE NOT NULL,
    DATA_GERACAO DATE NOT NULL,
    STATUS_USO BOOLEAN NOT NULL,
    ID_USUARIO INTEGER NOT NULL, -- Usuário que irá usar o ingresso
    FOREIGN KEY (ID_ITEM_PEDIDO) REFERENCES ITEM_PEDIDO (ID_ITEM_PEDIDO),
    FOREIGN KEY (ID_USUARIO) REFERENCES USUARIO (ID_USUARIO)
);


-- ######################################################################
-- # ETAPA 4: FUNÇÕES E TRIGGERS (INTEGRIDADE - MANTIDAS)
-- ######################################################################

-- NOTA: As funções e triggers permanecem inalteradas, pois lidam com a lógica
-- de negócio (Estoque e Cálculos), e não com a definição dos domínios (Tipos/Status).

-- Função para verificar estoque antes de inserir um item de pedido
CREATE OR REPLACE FUNCTION FN_Verifica_Estoque()
RETURNS TRIGGER AS $$
DECLARE
    estoque_disponivel NUMERIC;
BEGIN
    SELECT (QUANTIDADE_TOTAL - QUANTIDADE_VENDIDA) INTO estoque_disponivel
    FROM ESTOQUE_INGRESSO
    WHERE ID_TIPO_INGRESSO = NEW.ID_TIPO_INGRESSO;

    IF NEW.QUANTIDADE_COMPRADA > estoque_disponivel THEN
        RAISE EXCEPTION 'Estoque insuficiente: % ingressos disponíveis para o tipo %.',
        estoque_disponivel, NEW.ID_TIPO_INGRESSO;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Gatilho para verificar o estoque antes da inserção
CREATE TRIGGER TRG_Verifica_Estoque
BEFORE INSERT OR UPDATE ON ITEM_PEDIDO
FOR EACH ROW
EXECUTE FUNCTION FN_Verifica_Estoque();


-- Função para atualizar a quantidade vendida no estoque
CREATE OR REPLACE FUNCTION FN_Atualiza_Venda_Estoque()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE ESTOQUE_INGRESSO
    SET QUANTIDADE_VENDIDA = QUANTIDADE_VENDIDA + NEW.QUANTIDADE_COMPRADA
    WHERE ID_TIPO_INGRESSO = NEW.ID_TIPO_INGRESSO;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Gatilho para atualizar a quantidade vendida após a inserção do item
CREATE TRIGGER TRG_Atualiza_Venda_Estoque
AFTER INSERT ON ITEM_PEDIDO
FOR EACH ROW
EXECUTE FUNCTION FN_Atualiza_Venda_Estoque();


-- Função para recalcular o valor total do pedido
CREATE OR REPLACE FUNCTION FN_Recalcula_Valor_Total()
RETURNS TRIGGER AS $$
DECLARE
    novo_valor_total NUMERIC(10, 2);
BEGIN
    SELECT COALESCE(SUM(QUANTIDADE_COMPRADA * PRECO_UNITARIO_FINAL), 0)
    INTO novo_valor_total
    FROM ITEM_PEDIDO
    WHERE ID_PEDIDO = COALESCE(NEW.ID_PEDIDO, OLD.ID_PEDIDO);

    UPDATE PEDIDO
    SET VALOR_TOTAL = novo_valor_total
    WHERE ID_PEDIDO = COALESCE(NEW.ID_PEDIDO, OLD.ID_PEDIDO);

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Gatilho para garantir que VALOR_TOTAL do PEDIDO reflita a soma dos itens
CREATE TRIGGER TRG_Recalcula_Valor_Total
AFTER INSERT OR UPDATE OR DELETE ON ITEM_PEDIDO
FOR EACH ROW
EXECUTE FUNCTION FN_Recalcula_Valor_Total();


-- ######################################################################
-- # ETAPA 5: INSERÇÃO DE DADOS DE EXEMPLO (DML)
-- ######################################################################

-- POPULANDO AS TABELAS DE REFERÊNCIA PRIMEIRO (Ordem CRÍTICA)
INSERT INTO TIPO_USUARIO_REF (ID_TIPO_USUARIO, NOME) VALUES
(1, 'ORGANIZADOR'), (2, 'CLIENTE');

INSERT INTO STATUS_PEDIDO_REF (ID_STATUS_PEDIDO, NOME) VALUES
(1, 'PENDENTE'), (2, 'APROVADO'), (3, 'CANCELADO'), (4, 'REEMBOLSADO');

INSERT INTO METODO_PAGAMENTO_REF (ID_METODO_PAGAMENTO, NOME) VALUES
(1, 'PIX'), (2, 'CREDITO'), (3, 'DEBITO'), (4, 'BOLETO');

INSERT INTO STATUS_TRANSACAO_REF (ID_STATUS_TRANSACAO, NOME) VALUES
(1, 'AUTORIZADO'), (2, 'RECUSADO'), (3, 'PENDENTE'), (4, 'FALHA');


-- USUÁRIOS (Agora usam IDs das tabelas de referência)
INSERT INTO USUARIO (ID_USUARIO, NOME, EMAIL, SENHA, ID_TIPO_USUARIO) VALUES
(1, 'TechCorp Organizadora', 'tech@corp.com', 'h1', 1), -- ID 1 = ORGANIZADOR
(2, 'Ana Costa', 'ana.costa@email.com', 'h2', 2),      -- ID 2 = CLIENTE
(3, 'Bruno Lima', 'bruno.lima@email.com', 'h3', 2),
(4, 'Carla Dias', 'carla.dias@email.com', 'h4', 2),
(5, 'David Melo', 'david.melo@email.com', 'h5', 2);

-- ORGANIZADOR
INSERT INTO ORGANIZADOR (ID_ORGANIZADOR, NOME_FANTASIA, CNPJ, ID_USUARIO) VALUES
(1, 'Summit 2025', '12345678000190', 1);

-- EVENTO
INSERT INTO EVENTO (ID_EVENTO, DATA_HORARIO_INICIO, ENDERECO, NOME, ID_ORGANIZADOR) VALUES
(100, '2025-12-15 10:00:00', 'Centro de Convenções', 'Conferência de IA', 1);

-- SETOR
INSERT INTO SETOR (ID_SETOR, NOME_SETOR, CAPACIDADE, ID_EVENTO) VALUES
(1, 'Platéia Principal', 500, 100),
(2, 'Área VIP', 100, 100);

-- TIPO_INGRESSO
INSERT INTO TIPO_INGRESSO (ID_TIPO_INGRESSO, NOME, PRECO_BASE, TAXA_SERVICO, ID_SETOR) VALUES
(1, 'Geral - 1º Lote', 150.00, 15.00, 1),
(2, 'VIP', 500.00, 50.00, 2);

-- ESTOQUE_INGRESSO
INSERT INTO ESTOQUE_INGRESSO (ID_ESTOQUE, ID_TIPO_INGRESSO, QUANTIDADE_TOTAL) VALUES
(1, 1, 500),
(2, 2, 100);

-- PEDIDOS (Agora usam IDs para status: ID 2=APROVADO, ID 1=PENDENTE)
INSERT INTO PEDIDO (ID_PEDIDO, ID_USUARIO, ID_STATUS_PEDIDO, VALOR_TOTAL) VALUES
(1000, 2, 2, 165.00), -- Ana (APROVADO)
(1001, 3, 2, 330.00), -- Bruno (APROVADO)
(1002, 4, 2, 550.00), -- Carla (APROVADO)
(1003, 5, 2, 1100.00), -- David (APROVADO)
(1004, 2, 1, 165.00); -- Ana (PENDENTE)

-- PAGAMENTO (Agora usam IDs para método e status transação)
INSERT INTO PAGAMENTO (ID_PEDIDO, ID_METODO_PAGAMENTO, ID_STATUS_TRANSACAO, VALOR_PAGO) VALUES
(1000, 1, 1, 165.00), -- PIX (ID 1), AUTORIZADO (ID 1)
(1001, 2, 1, 330.00), -- CREDITO (ID 2), AUTORIZADO (ID 1)
(1002, 2, 1, 550.00), -- CREDITO (ID 2), AUTORIZADO (ID 1)
(1003, 1, 1, 1100.00); -- PIX (ID 1), AUTORIZADO (ID 1)

-- ITEM_PEDIDO
INSERT INTO ITEM_PEDIDO (ID_ITEM_PEDIDO, ID_PEDIDO, ID_TIPO_INGRESSO, QUANTIDADE_COMPRADA, PRECO_UNITARIO_FINAL) VALUES
(10, 1000, 1, 1, 165.00),
(11, 1001, 1, 2, 165.00),
(12, 1002, 2, 1, 550.00),
(13, 1003, 2, 2, 550.00),
(14, 1004, 1, 1, 165.00);

-- INGRESSO_DETALHE
INSERT INTO INGRESSO_DETALHE (ID_ITEM_PEDIDO, QR_CODE, DATA_GERACAO, STATUS_USO, ID_USUARIO) VALUES
(10, 'QR-A001', '2025-11-11', FALSE, 2),
(11, 'QR-B001', '2025-11-11', FALSE, 3), (11, 'QR-B002', '2025-11-11', FALSE, 3),
(12, 'QR-C001', '2025-11-11', FALSE, 4),
(13, 'QR-D001', '2025-11-11', FALSE, 5), (13, 'QR-D002', '2025-11-11', FALSE, 5),
(14, 'QR-A002', '2025-11-12', FALSE, 2);


-- ######################################################################
-- # ETAPA 6: CONSULTA FINAL COM JOIN NAS TABELAS DE REFERÊNCIA
-- ######################################################################

SELECT
    P.ID_PEDIDO AS "Pedido Nº",
    U.NOME AS "Comprador",
    PSR.NOME AS "Status Pedido",
    P.VALOR_TOTAL AS "Valor Total",
    MPR.NOME AS "Forma de Pagamento",
    STR.NOME AS "Status Transação",
    TI.NOME AS "Tipo Ingresso Vendido",
    IP.QUANTIDADE_COMPRADA AS "Qtd. Comprada"
FROM
    PEDIDO P
JOIN
    USUARIO U ON P.ID_USUARIO = U.ID_USUARIO
JOIN
    STATUS_PEDIDO_REF PSR ON P.ID_STATUS_PEDIDO = PSR.ID_STATUS_PEDIDO
LEFT JOIN
    PAGAMENTO PM ON P.ID_PEDIDO = PM.ID_PEDIDO
LEFT JOIN -- Join com Pagamento só ocorre se houver um registro de Pagamento
    METODO_PAGAMENTO_REF MPR ON PM.ID_METODO_PAGAMENTO = MPR.ID_METODO_PAGAMENTO
LEFT JOIN
    STATUS_TRANSACAO_REF STR ON PM.ID_STATUS_TRANSACAO = STR.ID_STATUS_TRANSACAO
JOIN
    ITEM_PEDIDO IP ON P.ID_PEDIDO = IP.ID_PEDIDO
JOIN
    TIPO_INGRESSO TI ON IP.ID_TIPO_INGRESSO = TI.ID_TIPO_INGRESSO
ORDER BY
    P.ID_PEDIDO;